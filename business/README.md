## 缓存击穿
典型场景描述：一个热点 key 失效后，导致大量请求直接访问数据库

### 避免失效
可以增加定时任务，在某些热点 key 失效之前重新生成缓存数据

### 即使失效了，也不让大量请求直接访问数据库
比如：缓存服务器坏了，热点 key 突然都没有了

可以针对热点数据库查询，增加分布式锁；
- 假设有 100 个请求进来，只有 1 个能抢到锁去查询数据库
- 其他 99 个请求都快速失败，直接提醒用户稍后重试

## 缓存穿透
典型场景描述：某个接口此时真的没有数据，如果没数据的时候不缓存，那依旧会有大量请求继续访问数据
```
// 去缓存读取数据，由于数据库本身就没有数据而造成缓存穿透
if (缓存有数据) {
  // 从缓存获取数据
} else {
  // 读取数据库
}
```

- null 和 []
- 允许缓存 null 数据；或者在业务上尽量自己写代码将 null 转成空列表数据 []
- 同时用分布式锁兜底

## 缓存雪崩
由于短时间内，大量的 key 失效，导致滚雪球式数据库压力剧增
典型场景：大量 key 配置的缓存过期时间同时或相近时间到期了

- 热点 key 可以让它不失效。但是存储空间有限，需要配合缓存过期策略
  - 场景缓存过期策略
    - TTL 超时时间
    - LRU 最近最少使用
    - LFU 最近最不经常使用
    - FIFO 先进先出
    - Random 随机淘汰策略（一般不用它）
- 本质方法：尽量将热点 key 过期时间「打散」
  - 比如现在的案例，key 跟 DailyTrainTicketListRequest 参数有关系，这个类型正好有分页、车次、起始站、终点站等组成，热点 key 相对容易分散
  - 主动缓存，主动打散
  - 加上「限流」操作
    - 对于多个 key，用之前说的分布式锁的方式不容易解决，因为锁主要针对的是单个 key 的解决方法，对于导致雪崩的多个 key 可以加「限流」操作

## 前端缓存
- 把一些数据存到 Session storage 或者 Local storage
- 把一些不会怎么变的数据直接放到 js 文件中，比如...
  - 车站数据，几乎隔很长时间才会变化一次
  - 车次基础数据等等